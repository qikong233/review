### iOS中的锁

#### 自旋锁

自旋锁与互斥锁有点类似，只是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行保持，调用者就一直循环在那里看是否该自旋锁的保持着已经释放了锁，“自旋”一次就是因此而得名。其作用就是为了解决某项资源的互斥作用。因为自旋锁不会引起调用者睡眠，所以自旋锁的效率远高于互斥锁。虽然它的效率比互斥锁搞，但是它也有不足的地方：

1. 自旋锁一直占用CPU，他在未获得锁的情况下，一直运行 ———— 自选，所以占用着CPU，如果不能在很短的时间内获得锁，这无疑会使CPU效率降低。

2. 在用自旋锁时有可能会造成死锁，当递归调用时有可能造成死锁，调用有些其他函数也可能搞成死锁，如copy_to_user()、copy_from_user()、kmalloc()。

因此要谨慎使用自旋锁，自旋锁只有在内核可抢占式或SMP的情况下才真正需要，单CPU且不可抢占式的内核下，自旋锁的操作为空操作。自旋锁适用于锁使用者保持锁时间比较短的情况下。

#### 互斥锁

互斥锁属于sleep-waiting类型的锁。例如在一个双核的机器上有两个线程，（线程A和线程B），它们分别运行在Core0和Core1上。假设线程A想要通过pthread_mutex_lock操作去得到一个临界区的锁，而此时这个锁整被线程B所持有，那么线程A就会被阻塞，Core0会在此时进行上下文切换讲线程A置于等待队列中，此时Core0就可以运行其他的任务（例如另一个线程C）而不必进行忙等待。而自旋锁则不然，它属于busy-waiting类型的锁，如果线程A是使用pthread_spin_lock操作去请求锁，那么线程A就会一直在Core0上进行忙等待并不断的进行锁请求，直到得到这个锁位置。

### 两种锁的加锁原理

互斥锁： 线程会从sleep (加锁) ————> running (解锁)，过程中有上下文切换，cpu抢占，信号的发送等开销。

自旋锁： 线程一直是runing(加锁 ————> 解锁)，死循环检测锁的标志位，机制不复杂。

对比：互斥锁的起始原始开销要高于自旋锁，但是基本是一劳永逸，临界区锁时间的大小并不会对互斥锁的开销造成影响，而自旋锁是死循环检测，加锁全程消耗cpu，起始开销虽然低于互斥锁，但是随着锁时间，加锁的开销是现行增长的。

### 两种锁的应用

互斥锁用于临界区持锁时间比较长的操作，比如下面这些情况都可以考虑

- 临界区有IO操作
- 临界区代码复杂或者循环量大
- 临界区竞争非常激烈
- 单核处理器

至于自旋锁的主要用在临界区持锁时间非常短且CPU自选不紧张的情况下，自旋锁一般用于多核服务器。

对比：互斥锁的起始原始开销要高于自旋锁，但是基本是一劳永逸，临界区锁时间的大小并不会对互斥锁的开销造成影响，而自旋锁是死循环检测，加锁全程消耗cpu，起始开销虽然低于互斥锁，但是随着锁时间，加锁的开销是现行增长的。

### 两种锁的应用

互斥锁用于临界区持锁时间比较长的操作，比如下面这些情况都可以考虑

- 临界区有IO操作
- 临界区代码复杂或者循环量大
- 临界区竞争非常激烈
- 单核处理器

至于自旋锁的主要用在临界区持锁时间非常短且CPU自选不紧张的情况下，自旋锁一般用于多核服务器。


### pthread_mutex

mutex叫做“互斥锁”，等待锁的线程会处于休眠状态。

初始化如果没有设置初始化属性，那么表示默认锁的类型是PTHREAD_MUTEX_NORMAL

这样子的话，如果对同一把锁锁了两次，那么就会造成死锁。

解决的办法就是使用递归锁，PTHREAD_MUTEX_RECURSIVE。

递归锁：允许同一个线程对同一把锁进行重复加锁。(同一个线程，同一把锁)

自旋锁：atmoic、OSSpinLock、dispatch_semaphore_t

互斥锁：pthread_mutex、@synchronized、NSLock、NSConditionLock、NSCondition、NSRecursiveLock
